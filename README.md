# C-SHARP-STUFF

http://www.c-sharpcorner.com/UploadFile/bhushanbhure/websocket-server-using-httplistener-and-client-with-client/




https://stackoverflow.com/questions/8261407/simple-c-sharp-websockets-server


https://habrahabr.ru/post/145077/



https://www.codeproject.com/Articles/1063910/WebSocket-Server-in-Csharp

https://github.com/ninjasource/websocket-server/tree/master/WebSockets



https://github.com/sta/websocket-sharp

https://ashyrokoriadov.github.io/category/c_sharp_questions

### «Что такое .Net Framework?»
Общеязыковая исполняющая среда common language runtime (CLR) + и библиотека классов framework class library (FCL).

### «Чем managed code отличается от unmanaged code?» -
Это означает, что CLR заботится об управлении памятью, о совместимости между платформами, о безопасности кода и так далее Это хорошо описано у Рихтера.

### ASP.NET проекта

ASP.NET — платформа от Microsoft для создания и развёртывания сайтов, веб-приложений и сервисов. По данным SimilarTech, около 2 000 000 сайтов используют эту платформу. В этой статье описаны первые шаги создания сайта на ASP.NET.

Для разработки будем использовать Visual Studio.

- Веб-формы — можно легко создавать динамические веб-сайты, используя сотни элементов управления и компонентов.
- MVC — эффективный, основанный на шаблонах способ создания динамических сайтов. Предоставляет полный контроль над разметкой для гибкой разработки.
- Веб-API — позволяет легко создавать HTTP службы для широкого диапазона клиентов. Идеальная платформа для сборки REST-приложений.
- Приложение SPA — одностраничное веб-приложение, которое загружает HTML-страницу и динамически обновляет её при взаимодействии с пользователем.
Выберете модель Веб-формы и завершите создание проекта.

Внутренняя структура проекта - В проекте сайта уже загружены некоторые библиотеки, необходимые для комфортного старта: CSS-фреймворк Bootstrap, JS-фреймворк jQuery, MSAjax и некоторые другие.

После создания тут уже присутствуют 3 страницы: Default, About и Contact. Каждая страница состоит из 3 файлов:

- Page.aspx — содержит в себе HTML-разметку конкретной страницы;
- Page.aspx.cs — отвечает за логику работы конкретной страницы;
- Page.aspx.designer.cs — является мостом между Page.aspx и Page.aspx.cs.

# ASP.NET https://coderlessons.com/tutorials/veb-razrabotka/uchebnik-asp-net/14-interviu-asp-net-web-api-voprosy-i-otvety

### ASP.NET - веб-сервисы WebService Класс (System.Web.Services)
Веб-сервис – это веб-приложение, которое представляет собой класс, состоящий из методов, которые могут использоваться другими приложениями.

NET в качестве операций Web сервиса, которые поддерживают HTTP, XML, XML Schema, SOAP и WSDL. Обработчик WebMethod (. asmx ) автоматически определяет, как ...



### 1) Что такое веб-API?
WebAPI – это фреймворк, который помогает вам создавать / разрабатывать HTTP-сервисы.

### 2) Почему требуется веб-API? Можно ли использовать сервисы RESTful с использованием WCF?
Да, мы все еще можем разрабатывать RESTful-сервисы с WCF. Однако есть две основные причины, побуждающие пользователей использовать веб-API вместо служб RESTful.

- Web API расширяет подход TDD (Test Data Driven) при разработке сервисов RESTful.
- Если мы хотим разрабатывать сервисы RESTful в WCF, вам, безусловно, понадобится много настроек конфигурации, шаблонов URI, контрактов и конечных точек для разработки сервисов RESTful с использованием веб-API.

###  Зачем выбирать веб-API?

- Он используется для создания простых HTTP-сервисов, не основанных на SOAP
- Это также простой метод для создания с помощью веб-API. С WCF REST Services
- Он основан на HTTP и прост в определении, представлении и использовании в режиме REST.
- Это легкая архитектура и идеально подходит для устройств с ограниченной пропускной способностью, таких как смартфоны.

### Правильно ли, что ASP.NET Web API заменил WCF?
Совсем не правда, что ASP.NET Web API заменил WCF. Фактически это еще один способ создания сервисов, не основанных на SOAP, т. Е. Простой XML или строки JSON.

### Каковы преимущества веб-API?

Преимущества веб-API:

- OData
- фильтры
- Согласование контента
- Self-хостинг
- Маршрутизация
- Привязки моделей

# Какие основные типы возвращаемых данных поддерживаются в Web API?

Действие контроллера Web API может возвращать следующие значения:

- Void – вернет пустой контент
- HttpResponseMessage – преобразует ответ в сообщение HTTP.
- IHttpActionResult – внутренне вызывает ExecuteAsync для создания HttpResponseMessage
- Другие типы – вы можете записать сериализованное возвращаемое значение в тело ответа

### АОП ООП

Аспектно-ориентированное

**Аспектно-ориентированное програмирование** базируется на изучении того сколько и каких компонент или частей требуется для взаимодействия с системой. Основным для АОП является взаимодействие этих элементов.

Интерфейсно-ориентированное

**Интерфейсно-ориентированное программирование** это подход основанный на программировании по контракту. Ни одна часть интерфейса не зависит от того как реализована другая, вся коммуникация между ними описана в контракте. Веб-сервисы на основе WSDL наиболее известный пример этого подхода.

Объектно-ориентированное

**Объектно-ориентированное программирование** основывается на понятиях абстракции, инкапсуляции, полиморфизма и наследования. Классы реализуют эти концепции для построение объектов, контролирующих или реализующих систему.

**Абстракция**
- Абстракция - отделение идеи от реализации
- позволяет уменьшить связывание между компонентами пердоставляя дополнительный слой между ними, для того чтоб один объект не зависил от того, как другой реализуюет свои бизнес-правила. (Интерфейсы, слои) Отличная штука, если вы хотите изолировать части системы так, чтоб их изменение или замена не стали проблеммой для работы системы в целом.

**Инкапсуляция**
- Инкапсуляция - приватные методы
- позволяет работать абстракции пряча детали реализации класса от вызывающих его. (Публичные и приватные поля)

**Наследование** 
- Наследование - повторное использование кода лучше реализовать с помощью агрегации или, что хуже, композиции)
- позволяет базовым(родительским) классам содержать общую функциональность и передавать ее всем своим классам-потомкам. Класс Figure(фигура) может иметь поле цвет, которое будет унаследовано его классами-потомками Square(квадрат) или Circle(круг).

**Полиморфизм**
- Полиморфизм - реализация идеи разными способами
- позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) поразному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding)

### «В чем разница инкапсуляции и сокрытия?»
Инкапсуляция предполагает формирование классов, т.е. размещение в одном месте сразу и структур данных, и методов. Инкапсуляция также предполагает установку области видимости структур данных и методов от использования их вне класса, в частности сокрытие данных и методов использую private.

### Что такое наследование и почему оно важно в разработке?
Наследование – одна из важнейших концепций объектно-ориентированного программирования, наряду с инкапсуляцией и полиморфизмом. Наследование позволяет разработчикам создавать новые классы, которые повторно используют, расширяют и изменяют поведение, определенное в других классах. Это позволяет повторно использовать код и ускоряет разработку. Благодаря наследованию, разработчики могут написать и отладить один класс только один раз, а затем повторно использовать этот же код в качестве основы для новых классов. Класс, от которого наследуются, называется базовым классом, а класс, который наследует, называется производным классом. По умолчанию все классы в .NET являются наследуемыми.

В общих терминах ООП наследование означает, что класс может быть основан на другом классе, при этом дочерний класс принимает атрибуты родительского класса. Например, программисты могут создать класс под названием Vehicle, а затем дочерние классы под названием Truck, Car и Motorcycle - все они наследуют атрибуты Vehicle.

Чтобы продемонстрировать свое понимание вопроса на собеседовании, кандидаты могут рассказать, как .NET поддерживает только одиночное наследование, что означает, что класс может наследовать только от одного другого класса. Их ответ может также коснуться транзитивного характера наследования - например, класс Ford наследуется от Car, который наследуется от Vehicle.

### Разница между классом и объектом
Класс – это определение объекта, а объект – это экземпляр класса.

Можно рассматривать класс как шаблон объекта: он описывает все свойства, методы, состояния и поведение, которыми будет обладать реализующий объект. Как уже говорилось, объект – это экземпляр класса, а класс становится объектом только после инициирования. На основе одного класса может существовать несколько экземпляров объектов, каждый из которых обладает различными свойствами.

### Различия между интерфейсом и абстрактным классом в .NET
**Интерфейс** просто объявляет поведение, которым должны обладать реализующие классы. Он объявляет только свойства, методы и события без модификаторов доступа. Все объявленные члены должны быть реализованы.

**Абстрактный класс** предоставляет частичную реализацию функциональности и некоторые абстрактные/виртуальные члены, которые должны быть реализованы сущностями, которые наследуют класс. Он также объявляет поля.

Интерфейс и абстрактный класс не могут быть инстанцированы.

В чем разница между абстрактным классом и интерфейсом?
Абстрактный класс всегда используется как базовый класс. Он предоставляет некоторые абстрактные / виртуальные члены, которые должны реализовывать наследующие сущности, а также частичную реализацию функциональности. Кандидаты могут упомянуть, что этот класс также может объявлять поля. Разработчики не могут создать объект из этого класса.

С другой стороны, интерфейс может объявлять только свойства, методы и события (без модификаторов доступа). Разработчик должен реализовать все заявленные члены. Короче говоря, интерфейс обозначает контракт / поведение, которые должны иметь реализующие классы.

### «Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Каким образом?»
- Да.
```
public class GiuseppePizzaria : IWindow, IRestaurant {
// Реализация метода GetMenu интерфейса IWindow.
Object IWindow.GetMenu() { ... }
// Реализация метода GetMenu интерфейса IRestaurant.
Object IRestaurant.SetMenu() { ... }
// Метод GetMenu, не относящийся к интерфейсам.

```

### Кому доступны переменные с модификатором protected на уровне класса?
Любому классу-наследнику.

### Наследуются ли переменные с модификатором private?
Да, но они не являются доступными.

### Опишите модификатор “protected internal”.
Члены с таким модификатором доступны классам, находящимся в той же сборке и унаследованным от данного класса.

### SOLID
- Single responsibility - объект, метод должны заниматься только одним своим делом, в противоположность антипатерну God-object
- Open closed principle - для добавления новых функций не должно требоваться изменять существующий код
- Liskov substitution - использовать базовый класс не зная о реализации наследника
- Interface segregation principle - не раздувать интерфейсы
- Dependency inversion principle - вначале интерфейсы, потом реализация, но не наоборот

### Паттерны
Порождающие паттерны:
- Одиночка 
- Абстрактная фабрика 
- фабричный метод
- Строитель 
- Прототип 

Структурные паттерны:
- Адаптер 
- Мост 
- Декоратор 
- Фасад 

Поведенческие паттерны:
- Команда 
- Посредник  Mediator
- Наблюдатель  Observer
- Шаблонный метод  Template Method
- Состояние  State
- Посетитель  Visitor
- Стратегия  Strategy

### Уровни изоляции транзакций
- Read uncommited (грязное чтение) - самая менее затратная транзакция - Если одновременно запустить две транзакции. Внести изменения (insert, update, delete) в первой транзакции, вторая увидит изменения даже до того как первая транзакция их закомитит.
- Read commited - Вторая транзакция видит insert, update, delete сделанные в первой транзакции только после комита первой транзакции.
- Repeatable read - Вторая транзакция видит insert-ы закомиченные первой транзакцией, но не видит updat-ы и delet-ы
- Serializable - самая затратная, наименьший уровень параллелизма
Нельзя работать с данными прочитанными в другой транзакции,

### Что еще спрашивают
- IDisposable, try, catch, finally
- Напишите singleton (не забудьте про потокобезопасность и lock)
- домены приложений
- синхронизации потоков (mutex, semaphore и т.п.)
- Позитивные/негативные блокировки. Например: первый пользователь открыл форму на редактирование. Пока первый правит, второй успел внести изменения. Первый нажимает сохранить. Хорошо это или плохо? Какие варианты решения проблемы (если она есть)?
- SQL запросы, особенно с HAVING

### Разница между управляемым и неуправляемым кодом
**Управляемый код** – это код, созданный компилятором .NET. Он не зависит от архитектуры целевой машины, поскольку выполняется CLR (Common Language Runtime), а не самой операционной системой. CLR и управляемый код предлагают разработчикам несколько преимуществ, таких как сборка мусора, проверка типов и обработка исключений.

С другой стороны, **неуправляемый** код напрямую компилируется в родной машинный код и зависит от архитектуры целевой машины. Он выполняется непосредственно операционной системой. В неуправляемом коде разработчик должен убедиться, что он вручную решает вопросы использования и выделения памяти (особенно из-за утечек памяти), безопасности типов и исключений.

В .NET компилятор Visual Basic и C# создает управляемый код. Чтобы получить неуправляемый код, приложение должно быть написано на C или C++.

### Что такое LINQ.
LINQ – это аббревиатура от Language Integrated Query, она была представлена в Visual Studio 2008. LINQ – это набор функций, расширяющих возможности запросов в синтаксисе языка .NET путем добавления наборов новых стандартных операторов запросов, которые позволяют манипулировать данными независимо от источника данных. Поддерживаемыми источниками данных являются: Коллекции .NET Framework, базы данных SQL Server, наборы данных ADO.NET, документы XML и любые коллекции объектов, поддерживающие IEnumerable или generic интерфейс IEnumerable<T>, как в C#, так и в Visual Basic. Одним словом, LINQ преодолевает разрыв между миром объектов и миром данных.
	
# ТИПЫ

### где хранится static class — в куче или стэке
- Статические методы (фактически все методы), а также статические переменные хранятся в разделе кучи PermGen,
- Простым ответом является куча. Классы и все данные, относящиеся к классам (не данные экземпляра), хранятся в разделе "Постоянное поколение кучи".

### stack и heap, value type и reference type
- reference type (пример class, interface) хранятся в heap
- value type (пример int, struct, ссылки на инстансы reference type) хранятся в быстром stack
- при присвоении (передачи в метод) value type копируются, reference type передаются по ссылке (см. ниже раздел struct)

### struct
- value type => при присвоении (передачи в метод) все поля и свойства копируются, не может быть null
- нет наследования
- поддерживает интерфейсы
- если есть конструктор, в нем должны устанавливаться все поля и свойства

### string особенный тип
- хранятся в heap как reference type, передаются в метод как reference type
- строки не изменяемы (immutable) - каждое изменение создает новый объект
- из-за того, что строки immutable и при сравнении сравниваются их значения (стандартное поведение reference type сравнивать ссылки) строки по поведению похожи на value type
- из-за immutable при склеивании длинных строк нужно использовать StringBuilder

### Разница между constant и readonly
- Constant и readonly имеют много общего, но есть некоторые важные различия:
- constant оценивается во время компиляции, в то время как readonly оценивается во время выполнения.
- constant поддерживает только переменные типа значения (единственным исключением являются строки), в то время как readonly может содержать переменные ссылочного типа.
- constant следует использовать, когда значение не меняется во время выполнения, а readonly используется в основном тогда, когда фактическое значение неизвестно до выполнения.
- readonly может инициализироваться только во время объявления или в конструкторе.	
	
### const vs readonly
- const - значение подставляется при компиляции => установить можно только до компиляции
- readonly - установить значение можно только до компиляции или в конструкторе

### ref и out
- ref и out позволяют передавать в метод ссылки на объекты, и для value type и для reference type
- ref и out позволяют внутри метода использовать new и для class и для struct
- out тоже что ref, только говорит о том что, метод обязательно пересоздаст переменную

### Ковариантность
- List<> инвариантен -> можно привести к переменной только того же типа
public class List<T>
- IEnumerable<> ковариантен -> часное можно привести к более общему
interface IEnumerable<out T> - указан out
- Action<> контрвариантен -> общее можно привести к частному (пример ниже)
delegate void Action<in T> - указан in


### К каким коллизиям приводит метод Add в List:
```
// это компилируется и работает

List<Cat> cats = new List<Cat>();
cats.Add(new Cat());
List<Cat> animals = cats;
animals.Add(new Cat());

foreach (var cat in cats) {
    cat.Meow(); // в cats 2 кошки
}


// это НЕ КОМПИЛИРУЕТСЯ

List<Cat> cats = new List<Cat>();
cats.Add(new Cat());
List<IAnimal> animals = cats;
animals.Add(new Dog()); // это не порядок, потому что:

// перебираем
foreach (var cat in cats) {
    cat.Meow(); // в cats 1 кошка и 1 собака, у собаки нет метода Meow()
}
```	

### Публичные методы Object
- ToString
- GetType
- Equals
- GetHashCode

### GetHashCode()
- GetHashCode НЕ возвращает уникальный ключ/хеш объекта. Разные объекты, даже одного типа, могут возвращать одинаковое значение - и это будет корректно.
- Соответственно, GetHashCode нельзя использовать для сравнения объектов (только как вспомогательную функцию).

- GetHashCode returns an Int32, which has “only” about 4.2 billion possible values, and there’s potentially an infinity of different objects
- So, if GetHashCode doesn’t return an id and cannot be used to test equality, what is it good for?
- GetHashCode mostly exists for one purpose: to serve as a hash function when the object is used as a key in a hash table. OK, but what is a hash table? Maybe the term doesn’t sound familiar to you, but if you’ve been programming in C# for more than a few hours, you’ve probably used one already: the Dictionary<TKey, TValue> class is the most commonly used hash table implementation. HashSet<T> is also based on a hash table, as the name implies. If you want a complete explanation of hash tables, Wikipedia has a pretty good article, but I’ll try to give a brief introduction here.
	
	
**GetHashCode** нужен для быстрого поиска в хеш-таблицах. Такие объекты как HashSet<T> и Dictionary<TKey, TValue> используют в своей работе хеш-таблицы.
Если объект используется в качестве ключа в хеш-таблице, то значение его GetHashCode указывает на позицию в хеш-таблице. При этом на одной позиции может быть несколько разных элементов (у которых одинаковый GetHashCode).

Псевдокод поиска в хеш-таблице:
1. вначале ищем позицию в хеш-таблице
2. среди элементов этой позиции ищем элемент используя Equals
	

### Finalizer 
- вызывается когда garbage collector доберется до объекта. Можно указать GC не вызывать finalizer для определенного instance - GC.SuppressFinalize.
- вызывается только автоматически средой .Net, нельзя вызвать самостоятельно (если очень хочется можно вызвать с помощью reflection).
- нельзя определить для struct
- зачем может пригодиться переопределять finalizer: предпочтительней реализовать IDisposable. Встречаются идеи дублировать логику Dispose в finalizer, на случай если клиентский код не вызывал Dispose. Или вставлять в finalizer логирование времени жизни объекта для отладки.

### Разница между stack и heap
### Разница между стек и куча / стеком и кучей / кучей и стеком
В stack хранятся типы значений(типы, унаследованные от System.ValueType), а в heap – ссылочные типы (типы, унаследованные от System.Object).

Можно сказать, что stack отвечает за отслеживание того, что на самом деле выполняется и где находится каждый выполняющийся поток (каждый поток имеет свой собственный стек). Heap, с другой стороны, отвечает за хранение данных, или, более точно, объектов.
	
### Garbage collector
### СБРОЩИК МУСОРА
- Коротко. heap большая, но все же имеет ограниченный размер, нужно удалять неиспользуемые объекты. Этим занимается Garbage collector. Деление объектов на поколения нужно для следующего:
- выявление есть ссылки на объект (объект используется) или его можно удалить - это трудозатратная задача
- поэтому имеет смысл делать это не для всех объектов в heap
- те объекты которые создали недавно (Generation 0) - вероятно это объекты используемые внутри метода, при выходе из метода они не нужны их можно удалить. Поэтому вначале искать объекты на удаление нужно в поколении Generation 0.
- те объекты которые пережили сборку мусора - называют объектами Generation 1.
- если Generation 0 почистили, а памяти не хватает. Приходится искать ненужные объекты среди тех которые пережили сборку - в Generation 1.
- если все равно нужно еще чистить, ищем среди тех кто пережили 2 сборки мусора - в Generation 2.
	
### Что такое сборщик мусора и как он работает. Приведите пример кода, показывающий, как можно обеспечить сборку мусора в .NET
**Сборка мусора** – это низкоприоритетный процесс, который служит в качестве автоматического менеджера памяти, управляющего распределением и освобождением памяти для приложений. Каждый раз, когда создается новый объект, среда выполнения общего языка выделяет память для этого объекта из управляемой кучи. Пока в управляемой куче есть свободное пространство памяти, среда выполнения продолжает выделять место для новых объектов. Однако память не бесконечна, и как только приложение заполняет пространство, в дело вступает сборщик мусора (Garbage Collector), который освобождает часть памяти. Когда сборщик мусора выполняет очистку, он проверяет объекты в управляемой куче, которые больше не используются приложением, и выполняет необходимые операции. Сборщик мусора останавливает все запущенные потоки, находит все объекты в куче, к которым не обращается основная программа, и удаляет их. Затем он собирает все объекты, оставшиеся в куче, чтобы освободить место, и корректирует все указатели на эти объекты в стеке и в куче.

Чтобы запустить сборку мусора в коде вручную, выполняем следующую команду:
```
System.GC.Collect();
```	

### Порядок инициализации
- Derived.Static.Fields
- Derived.Static.Constructor
- Derived.Instance.Fields
- Base.Static.Fields
- Base.Static.Constructor
- Base.Instance.Fields
- Base.Instance.Constructor
- Derived.Instance.Constructor
	
#  CLR

### Что такое CLR? Что такое IL? Что такое CLS?
CLR ("Common Language Runtime", "общеязыковая исполняющая среда") - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.

IL (Intermediate Language) - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

CLS ("Common Language Specification", общеязыковая спецификация) - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

### Что означают следующие аббревиатуры в .NET: IL, CIL, MSIL, CLI и JIT?
IL (Intermediate Language) – это независимый от процессора частично скомпилированный код. Код IL будет скомпилирован в родной машинный код с использованием текущих свойств среды компилятором Just-In-Time (JIT). JIT-компилятор переводит IL-код в код сборки и использует архитектуру процессора целевой машины для выполнения приложения .NET. В .NET язык IL называется Common Intermediate Language (CIL), а на первых этапах .NET он назывался Microsoft Intermediate Language (MSIL).

CLI (Common Language Infrastructure) – это открытая спецификация, разработанная компанией Microsoft. Это библиотека скомпилированного кода, используемая для развертывания, создания версий и обеспечения безопасности. В .NET существует два типа CLI: сборки процессов (EXE) и сборки библиотек (DLL). Сборки CLI содержат код на языке CIL, и, как уже упоминалось, при компиляции языков программирования CLI исходный код транслируется в код CIL, а не в объектный код, специфичный для платформы или процессора.

Подведем итоги:

- При компиляции исходный код сначала транслируется в IL (в .NET это CIL, а ранее назывался MSIL).
- Затем CIL собирается в байткод и создается сборка CLI.
- Перед выполнением кода CLI-код проходит через JIT-компилятор среды выполнения для генерации родного машинного кода.
- Процессор компьютера выполняет родной машинный код.
	
	
### Что такое managed code?
Управляемый код (managed code) - это код, работающий в среде CLR. Содержит метаданные, в которых находится информация для среды выполнения - о типах, членах и ссылках, используемых в коде.

### Что такое assembly?
Сборка (assembly) - один или несколько файлов, содержащий логический набор функциональности (код и другие данные, связанные с кодом). Бывают статические сборки, хранящиеся на диске, и динамические, которые создаются во время выполнения программы. Сборка - это базовый блок приложения, все ресурсы, относящиеся к ней, доступны или только внутри этого блока, или экспортируются наружу. При выполнении сборка задает область видимости имен и следит за ее соблюдением.

### Что такое приватные и совместные сборки?
Сборки (assembly) бывают двух типов - приватные (private), которые использует только само приложение, и совместные (shared), использующиеся набором приложений. При приватных сборках приложение изолируется от внешнего воздействия программ и операционной системы, отпадает необходимость заботиться об уникальности имен в глобальном пространстве имен. Чтобы сделать сборку совместной, ее необходимо специальным образом собрать и присвоить ей строгое шифрованное имя.

### Что такое assembly manifest?
Манифест сборки (assembly manifest) - это внутренняя часть сборки, которая позволяет ей быть самоописанной. Assembly manifest позволяет идентифицировать сборку, указывает файлы, которые включаются в реализацию сборки, описывает типы и ресурсы, используемые в сборке, указывает зависимости от других сборок, а также набор прав доступа, которые необходимы сборке для корректной работы. Эта информация используется во время выполнения для разрешения ссылок, проверку корректности версий, проверку целостности загруженных сборок.

### В чем разница между понятиями namespace и assembly?
Namespace (пространство имен) является логическим соглашением, используемым во время разработки, в то время как assembly (сборка) устанавливает область видимости имени в процессе выполнения.

### В чем различие между Value Type и Reference Type?
Value Type находятся в стеке, а Reference Type в куче.

### Когда объект удаляется сборщиком мусора?
Объект удаляется сборщиком мусора, когда на него не остается ссылок.

### Что такое Code Access Security (CAS)?
CAS - это защитная технология, позволяющая установить ограничение на исполнение управляемого кода. Таким образом можно определить разрешения и установить права доступа к ресурсам компьютера.

### Что такое attribute?
Атрибут (attribute) - это универсальное средство связи данных с типами, позволяют добавлять любую текстовую информацию о классах, свойствах, методах и т.д. Атрибуты сохраняются с метаданными и могут быть получены при выполнении программы.

### Как обеспечить использование именованных параметров в конструкторе атрибута?
Конструкторы атрибутов могут принимать именованные параметры — поля и свойства атрибутов. При задании именованного параметра в конструктор атрибута передается имя свойства или поля, которое должно принять этот параметр. При чем эти свойства и поля должны быть открытыми. Если именованные параметры передаются, то они обязательно должны идти следом за позиционными параметрами, которые явно указаны в конструкторе атрибута. Указание именованных параметров не является обязательным, поэтому при проектировании атрибутов необходимо помнить о том, что некоторые его поля или свойства могут быть не проинициализированы. Пример использования именованных параметров в конструкторе атрибута:
```
[DllImport("Kernel32", CharSet=CharSet.Auto, SetLastError=true)]
```
Здесь передается 1 позиционный параметр — строка "Kernel32" и 2 именованных параметра, которые устанавливают открытые поля CharSet и SetLastError в значения CharSet.Auto и true соответственно.

### В чем различие между Finalize и Dispose?
- Dispose - обеспечивает явный контроль над ресурсами, используемыми объектом

- Finalize - неявный, используемый сборщиком мусора.

### Разница между boxing и unboxing. Приведите пример.
Boxing – это процесс преобразования типа значения в тип объекта, а unboxing – извлечение типа значения из объекта. Boxing является неявным, unboxing – явным.
Пример:
```
int i = 13;
object myObject = i; 	// boxing 
i = (int)myObject;	// unboxing 
```
	
### Что такое Boxing и Unboxing?
```
// boxing (value type, stack -> object, heap)
int i = 123;
object o = i;

// unboxing (object, heap -> value type, stack)
object o = 123;
var i = (int)o;

// пример boxing
int i = 123;
object o = i; // фактически создалась копия "ещё одна" "коробочная" i в куче
i = 456; // а эта i оригинальная, и она осталась на стеке
// результат ==> т.к. i, o хранятся в разных ячейках памяти
//  i = 456
//  o = 123

------------------------

// boxing i
int i = 2;
string s = "str" + i;
// т.к. это String.Concat(object? arg0, object? arg1)

// unboxing, т.к. Session Dictionary<string, object>
int i = (int)Session["key"];
```


### Что такое Boxing и Unboxing?
**Упаковка (boxing)** позволяет преобразовать размерный тип в ссылочный. При упаковке объекта размерного типа происходят следующие действия:

Выделяется память в управляемой куче.
Совершается копирование полей размерного типа в память, которая была выделена в куче.
Возвращается адрес объекта.
Некоторые компиляторы автоматически создают IL-код, необходимый для упаковки объекта размерного типа. Процесс извлечения адреса полей из упакованного объекта называется распаковкой (unboxing). 

**Распаковка** не является полной противоположностью упаковке. В отличие от упаковки при распаковке не происходит никакого копирования. Однако обычно вслед за распаковкой следует копирование полей, поэтому обе операции (распаковка и копирование) являются противоположностью операции упаковки. Приведем пример использования упаковки и распаковки.
```
struct Point {
   public Int32 x, у;
}
 
class App {
   static void Main() {
      ArrayList a = new ArrayList();
      Point p; 		 	// Выделяется память для Point (не в куче).
      for (Int32 i = 0 ; i < 10; i++) {
         p.x = p. у = i; 	// Инициализация членов в нашем размерном типе.
         a.Add(p); 	 	// Упаковка размерного типа и добавление ссылки в ArrayList.
	}
 
	Point р1 = (Point) a[0]; 	// распаковка и копирование полей
}
```
Упаковка и распаковка/копирование снижают производительность приложения как в плане замедления, так и в расходе дополнительной памяти, поэтому нужно стараться минимизировать создание кода, в котором происходят операции упаковки и распаковки/копирования.


### то такое GAC?
GAC — это глобальный кэш сборок. В нем хранятся совместно используемые сборки. Обычно это каталог С:\Windows\Assembly\GAC. Этот каталог имеет определенную структуру, в котором хранятся подкаталоги, имена которых сгенерированы по определенному алгоритму. В GAC можно поместить только сборки со строгими именами. Для того, чтобы поместить сборку в GAC, используют специальный инструмент GACUtil.exe, который знает всю внутреннюю структуру GAC и может генерировать имена подкаталогов надлежащим образом. Регистрировать в GAC сборки необходимо для того, чтобы избежать конфликтов имен сборок. Приведем пример: две компании выпустили сборку и назвали ее одним именем Calculus. Если мы скопируем эту сборку в каталог, в котором уже находится сборка с таким же именем, то мы затрем сборку, которая ранее могла использоваться каким-то приложением. Это приложение с новой сборкой теперь работать не сможет. Решением этой проблемы будет регистрация этих двух сборок в GAC, в котором для каждой будет создан отдельный каталог.

### Какие типы можно использовать в предложении foreach?
Массивы, коллекции. Классы в которых реализован интерфейс System.Collections.IEnumerable.

### В чем различие между классом и структурой?
Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи). В свою очередь размерные типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.In132, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

### Что означает модификатор virtual?
При наследовании класса. Данный метод м.б. переопределен в производных классах с помощью ключевого слова override.

### Что такое делегаты в .NET?
Делегат в .NET похож на указатель функции в C или C++. Использование делегата позволяет программисту заключить ссылку на метод внутри объекта делегата. Затем объект делегата может быть передан в код, который может вызвать метод, на который ссылается ссылка, необязательно знать во время компиляции, какой метод будет вызван. Кроме того, можно использовать делегат для создания пользовательских событий в классе. Например:

```        
public delegate void FooDelegate();

class FooClass
{
    // кастомное событие
    public event FooDelegate FooEvent;
}

FooClass FooObj = new FooClass()
FooObj.FooEvent += new FooDelegate();
```				
				
### Отличается ли Delegate от Action?
			
Func и Action обобщенные делегаты были введены в .NET Framework начиная с NET 3.5. Они обеспечивают гибкость делегатов с общими параметрами. Делегат Func предназначен для инкапсуляции метода, который принимает в качестве параметров от нуля для четырех аргументов и возвращает значение. Что же касается делегата Action, то единственное отличие его от Func – это то, что Action возвращает процедуру.

- Обобщенные делегаты
Func и Action обобщенные делегаты были введены в .NET Framework начиная с версии 3.5. Они обеспечивают гибкость делегатов с общими параметрами, которые могут быть использованы для различных целей, в том числе успешно лямбда-выражений к параметрам метода. Делегат Func предназначен для инкапсуляции метода, который принимает в качестве параметров от нуля дл четырех аргументов и возвращает значение. Что же касается делегата Action, то единственное отличие его от Func – это то, что Action возвращает процедуру.
				
### Чем отличается event от delegate?
Delegate – это по сути указатель на функцию.

В С# модель издатель — подписчик, где класс публикует событие, которое он может инициировать, и любые классы могут подписаться на это событие. Метод, вызываемый при возникновении события, определяется делегатом

### Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Каким образом?
Да.
```
public class GiuseppePizzaria : IWindow, IRestaurant 
{
   // Реализация метода GetMenu интерфейса IWindow.
   Object IWindow.GetMenu() { ... }
   // Реализация метода GetMenu интерфейса IRestaurant.
   Object IRestaurant.GetMenu() { ... }
}
```


### Поддерживает ли C# множественное наследование?
С# поддерживает множественное наследование в виде наследования от класса и нескольких интерфейсов, или просто от нескольких интерфейсов.

Но не поддерживает наследование от нескольких классов.

### Кому доступны переменные с модификатором protected на уровне класса?
Любому классу-наследнику

### Наследуются ли переменные с модификатором private?
Да, но они не являются доступными.

### Опишите модификатор “protected internal”
Члены с таким модификатором доступны классам, находящимся в той же сборке и унаследованным от данного класса.

### Назовите класс .NET, от которого наследуются все классы?
System.Object.

### Что обозначает термин immutable (неизменяемый)?
Это значит, что данные, хранящиеся в переменной, не могут быть изменены. При этом заметьте, что значение переменной может быть изменено - путём отказа от использования старых данных, которые могут быть изменены. Оригинальные данные остаются в памяти, а новые значения создаются вновь, в новой области памяти. Пример тип String.

### Какая разница между классами System.String и System.Text.StringBuilder?
Данные, хранящиеся в классе **System.String** и есть неизменяемые (immutable). Класс **System.StringBuilder** разрабатывался так, чтобы над изменяемой строкой можно было проделать множество операций. То есть при каждой операции над объектом класса System.String происходит перенос данных в новую область памяти, что влияет на производительность программы.

### Какое преимущество использования класса System.Text.StringBuilder перед System.String?
Класс StringBuilder более эффективен в случае работы с большим количеством строк. Объекты класса System.String неизменяемы, поэтому при каждом изменении строки создаётся новый объект в памяти.

### Можно ли хранить разные типы данных в объекте класса System.Array?
Да
```
static void Main(string[] args) 
{
    object[] arr = new object[] { "string", 0, new Guid() };
    foreach (object var in arr)
    {
        Console.WriteLine(var.GetType().ToString());
    }
    Console.ReadKey();
     double d = 0.0;
    ValueType[] arr2 = new ValueType[] { d, 0, new Guid() };
    foreach (ValueType var in arr2)
    {
        Console.WriteLine(var.GetType().ToString());
    }
    Console.ReadKey();
} 
```

### Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?
Первая операция осуществляет **глубокое копирование** массива, а вторая – поверхностное. Поверхностное копирование массива копирует только сами элементы объекта класса Array, независимо от того являются они ссылочными или значимыми типами. Копирования объектов, на которые ссылаются ссылочные типы не происходит. Ссылки в новом объекте класса Array указывают на те же объекты, что и ссылки в оригинальном массиве Array. Глубокое копирование копирует как элементы класса Array, так и объекты, на которые они явно или неявно ссылаются.

### Как отсортировать элементы массива в убывающем порядке?
Нужно вызвать метод Sort(), а затем метод Reverse().

### As, is – что это, как применяется?
 С помощью оператора as программа пытается преобразовать выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение null.

Выражение o is Employee проверяет, является ли переменная o объектом типа Employee. 

Операторы приведения типов.
```
If(o is Employee){

Employee e = (Employee) o;

}
```



### В чем разница между throw ex; и throw;?
- throw повторно выбрасывает исключение (re-throw), которое было обнаружено, и сохраняет трассировку стека (путь к источнику исключения).
- throw ex генерирует одно и то же исключение, но сбрасывает трассировку стека на метод, где делается throw ex.

### Как работает return в try-catch-finally?

Алгоритм приблизительно такой:
1. Выполняется код перед оператором return;
2. Выражение в return оценивается
3. Выполняется finally блок
4. Возвращается результат, посчитанный на шаге 2

Рассмотрим следующий код:

```
public static async Task Main()
        {
            Console.WriteLine(MyMethod().Text);
            Console.ReadKey();
        }

        public static TestClass MyMethod()
        {
            var number = new TestClass
            {
                Text = "5"
            };
            try
            {
                return number;
            }
            catch
            {
                number.Text = "haha";
                return number;
            }
            finally
            {
                number.Text = "finally";
            }
        }
```
Что мы получим на экране?

finally

почему так? Мы не меняли результат который был получен на шаге 2, мы изменили значение свойства ссылочного типа, но не меняли сам объект

Если мы перепишем блок finally следующим образом:
```
...
finally
{
   number = new TestClass {Text = "finally"};
}
```
то получим в ответ 

5

Если мы проделаем это с value type, результат будет тем же. Т.е в блоке finally нельзя изменить возвращаемый объект, но можно менять свойства объекта.


# Вопросы по классам

### Какой синтаксис используется для указания класса родителя в C#?
После имени класса наследника нужно поставить двоеточие и указать имя базового класса. Пример:

class ChildClass : ParentClass

### Можно ли запретить наследование от своего собственного класса?

Да. Для этого служит ключевое слово “sealed”.


### Можно ли разрешить наследование класса, но запретить перекрытие метода?
Да. Указываем класс как public, а метод как sealed.

### Что такое абстрактный класс?
Это класс, объект которого не может быть создан. Такой класс должен иметь класс-наследник с реализацией абстрактных методов. Абстрактный класс – это фактически чертёж нормального класса без реализации.

### В каком случае вы обязаны объявить класс абстрактным?
- В том случае, если класс является наследником абстрактного класса, но не все методы базового класса перекрыты и имеют реализацию.
- В том случае, если хотя бы один метод класса является абстрактным.

### Что такое интерфейс класса?
Интерфейсы, как и классы, определяют набор свойств, методов и событий. Но, в отличие от классов, они не содержат их реализации. Интерфейсы реализуются классами и определяются как самостоятельные сущности.

### Почему нельзя указать модификатор видимости для методов интерфейса?
Потому что все они должны иметь модификатор public, который и установлен по умолчанию.

### Можно ли наследовать от нескольких интерфейсов?
Да.

### Назовите отличия между интерфейсом и абстрактным классом?
В интерфейсе все методы (свойства и т.д.) абстрактны и не имеют реализации. В абстрактном классе некоторые методы могут быть реализованы. В интерфейсе члены не могут иметь модификатора видимости (все они являются public по умолчанию), а в абстрактном классе члены могут иметь модификатор видимости.

### Назовите различия между структурами и классами.
Для С# классы System.Object, System.Exception, System.File-Stream и System.Random — это ссылочные типы (память выделяется из упр. кучи). В свою очередь размерные типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.In132, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.10.FileAttributes и System.Drawing.FontStyle являются размерными типами (хранятся обычно в стеке потока, но могут быть встроены в ссылочные типы).

### В чем разница между абстрактными и виртуальными классами? Между виртуальными и абстрактными методами?
- Абстрактный класс это класс, содержащий хотя бы один метод (abstract).. 
- Виртуальный метод имеет реализацию и м.б. переопределен в производном классе. 
- Абстрактный метод не имеет реализацию, только описание метода, который д.б. реализован в производных классах.

### Dispose(), Finalize() – что это за методы, как используются в .NET?
Используются для освобождения ресурсов. Применяя метод Dispose, вы должны обеспечить неявную очистку методом Finalize. Если программисту не удалось вызвать метод Dispose, использование метода Finalize предотвращает постоянную утечку ресурсов.

### Для чего в .NET используется конструкция using(…){…}? Причем тут IDisposable?
Значение Using непосредственно связано с интерфейсом IDisposable. Интерфейс IDisposable представляет нам возможность быстро освободить общие ресурсы, не полагаясь на автоматический сборщик мусора (garbage collector). Конструкция Using позволяет вызывать метод Dispose автоматически, как только нужный объект выйдет за блок Using.


# Вопросы по методам и свойствам

### Назовите явное имя параметра, передаваемого в метод set свойства класса?
value. Тип этого параметра определяется типом свойства.

### Что обозначает ключевое слово “virtual” для метода или свойства?
То, что метод или свойство может быть перекрыто.

### Чем перекрытый метод отличается от перегруженного метода?
При **перекрывании** метода мы изменяем его поведение в классе наследнике. **Перегрузка** метода просто приводит к использованию другого метода с тем же именем внутри класса.

### Можно ли объявить перекрытый метод статическим, если перекрываемый метод не является статическим?
Нет. Сигнатура виртуального метода должна остаться постоянной, кроме замены ключевого слова virtual на ключевое слово override.


# Вопросы по сборкам

### Что такое «сопутствующая сборка» (satellite assembly)?
Сборки, помеченные определенными региональными стандартами, называются сателлитными сборками

### Какая наименьшая исполнимая единица в .NET?
сборка

### Что происходит в памяти при упаковке и распаковке значимого типа?
При упаковке экземпляра размерного типа происходит следующее.

В управляемой куче выделяется память. Ее объем определяется длиной размерного типа и некоторыми накладными расходами, позволяющими этому размерному типу стать настоящим объектом. Этими накладными расходами являются указатель на таблицу методов и индекс SyncBlocklndex.
Поля размерного типа копируются в память, выделенную только что в куче.
Возвращается адрес объекта. Этот адрес является ссылкой на объект; размерный тип превратился в ссылочный.
Распаковка не является точной противоположностью упаковки.

Она состоит только в получении указателя на исходный.

размерный тип (поля данных), содержащийся в объекте. И никакого копирования при распаковке (в отличие от упаковки). Однако обычно вслед за распаковкой выполняется копирование полей, поэтому в сумме обе эти операции являются отражением операции упаковки
				
				
				
# КОНТЕЙНЕРЫ

### Объясните разницу между стеком и очередью
Этот вопрос для собеседования по .NET проверяет базовые знания кандидатов о коллекциях. Наряду со стопками и очередями в эту категорию входят хеш-таблицы, пакеты, словари и списки. Стек отслеживает, что выполняется, и содержит типы сохраненных значений, которые должны быть доступны и обработаны как LIFO (Last-In, First-Out), с элементами, вставленными и удаленными.

Очередь, с другой стороны, перечисляет элементы по принципу FIFO (First-In, First-Out) с точки зрения как вставки, так и удаления, с элементами, вставленными с бек стороны и удаленными с фронтенд стороны очереди.
				
				
				
				
				
# повторы
				
### 8. Что такое веб-служба .NET?
Веб-сервисы - это повторно используемые компоненты, которые позволяют разработчикам публиковать функцию приложения через Интернет, чтобы сделать его доступным и напрямую взаимодействовать с другими приложениями и объектами в нем. Веб-службы взаимодействуют с помощью стандартных веб-протоколов и форматов данных, включая HTTP, XML и SOAP, что позволяет им подключаться между различными платформами и языками программирования. ASP.NET предоставляет простой способ разработки веб-служб. .NET Framework предоставляет встроенные классы для создания и использования веб-служб.

### 9. Когда следует использовать .NET Web Forms вместо ASP.NET MVC?
Традиционно .NET Framework был основан на веб-формах. По сути, это была попытка создать веб-службы с использованием существующих инструментов Microsoft Visual Studio Tools, не заставляя разработчиков изучать новые языки сценариев. Веб-формы по-прежнему позволяют разработчикам создавать быстрые и простые приложения, а некоторые устаревшие системы могут по-прежнему работать как веб-формы.

Однако ASP.NET MVC становится стандартом для современных разработчиков. На собеседовании по .NET сильный кандидат должен быть в состоянии выделить преимущества архитектурного шаблона модель-представление-контроллер (MVC). Наиболее важной особенностью MVC является то, что он позволяет разбивать приложения на дискретные модели, представления и контроллеры, что значительно упрощает их тестирование во время разработки.

### 10. Что такое данные JSON и как разработчики .NET могут работать с JSON?
JSON (объектная нотация JavaScript) предоставляет разработчикам возможность упорядочивать и хранить данные, чтобы их было легко получить доступ и прочитать. JSON важен для разработчиков, поскольку он позволяет им управлять потоками JSON с других сайтов и загружать их быстрее и проще, чем через каналы SML / RSS. Json.NET предоставляет разработчикам .NET возможность определять классы, которые анализируют объекты и массивы из текста JSON. Вы также можете использовать Json.NET, если вам нужно сериализовать типы значений в текст JSON. Json.NET работает на .NET2, .NET3 и .NET4.

### 11. Объясните разницу между управляемым и неуправляемым кодом
Подобные вопросы на собеседовании по .NET позволяют кандидатам продемонстрировать свое понимание Common Language Runtime (CLR), ключевой части .NET Framework. Код, написанный на C # или Visual Basic .NET, после компиляции будет выполняться только в среде CLR, которая обеспечивает такие функции, как сборка мусора и управление памятью. Преимущество этого заключается в том, что управляемый код не зависит от платформы, поскольку он выполняется в среде CLR, а не в операционной системе компьютера, обращающегося к приложению.

Код, написанный на других языках, таких как C или C ++, создает неуправляемый код, а это означает, что разработчики не могут полагаться на CLR для обеспечения такого рода переносимости. Управляемый и неуправляемый код совместимы . Примеры неуправляемого кода, используемого в .NET, включают компоненты COM, интерфейсы ActiveX и функции Win32 API.

### 12. Дайте определение LINQ
LINQ расшифровывается как Language-Integrated Query. Это модель программирования и методология Microsoft, которая предлагает разработчикам способ манипулировать данными с использованием краткого, но выразительного синтаксиса. Это достигается путем внедрения языков программирования на основе Microsoft .NET с возможностью делать формальные запросы. Он является частью C # и может быть импортирован как библиотека на других языках.

### 13. Доступные только для чтения переменные и константы имеют много общего, но чем они отличаются?
Вот два возможных ответа на подобные вопросы собеседования по .NET:
Переменные только для чтения могут поддерживать переменные ссылочного типа. Константы могут содержать только переменные типа значения.
Разработчики оценивают переменные только для чтения во время выполнения. Они оценивают константы во время компиляции.

### 14. Что означают термины boxing и unboxing?
Этот вопрос может показать, насколько кандидаты знают о типах данных и принципах ООП. Идея относительно проста: упаковка - это процесс, который преобразует тип значения в тип объекта - путем «упаковки» переменной внутри выделенного объекта или интерфейса. Распаковка извлекает это значение и сохраняет его в виде значения. Бокс был необходим в некоторых старых типах коллекций, таких как ArrayList, и все еще может использоваться для точного преобразования типов - например, из двойного в int.

### 15. Какие три общих акронима используются в .NET и что они обозначают?
Кандидатам в .NET разработчики должно быть легко ответить на этот вопрос. Вопрос дает им некоторую гибкость в выборе терминов, которые им наиболее знакомы. Три часто используемых аббревиатуры в .NET - это IL, CIL и CLI:

IL означает Intermediate Language, объектно-ориентированный язык программирования, представляющий собой частично скомпилированный код, который разработчики .NET затем скомпилируют в собственный машинный код.
CIL расшифровывается как Common Intermediate Language, ранее известный как Microsoft Intermediate Language (MSIL). Это еще один язык программирования, который используют разработчики .NET, и он представляет собой минимально возможный уровень языка, который люди все еще могут читать.
CLI расшифровывается как Common Language Infrastructure. Это скомпилированная библиотека кода, разработанная Microsoft как открытая спецификация. Разработчики используют интерфейс командной строки для обеспечения безопасности, управления версиями и развертывания.
Другие сокращения, обычно используемые в .NET, включают JIT (Just-In-Time) компилятор, который использует архитектуру ЦП целевой машины для выполнения операции .NET; ООП (объектно-ориентированное программирование), определенное в вопросе 1; CLR (Common Language Runtime), определенный в Вопросе 11; и LINQ (Language-Integrated Query), определенный в вопросе 12.

### 16. В чем разница между .NET и Laravel?
Это один из самых простых вопросов на собеседовании по .NET, который вы можете задать. Большинство веб-разработчиков, по крайней мере, знакомы с альтернативными фреймворками, такими как Laravel, и смогут обсудить некоторые различия между этими платформами и .NET. Этот разговор позволит вам копнуть и выяснить, в чем заключаются интересы кандидатов и как они видят роль разработчика .NET. Например, они могут сосредоточиться на:

### Языки (например, поддержка C # в .NET по сравнению с поддержкой PHP в Laravel)
Безопасность
Интеграция .NET с Visual Studio
Сторонние библиотеки
Поддержка сообщества разработчиков ПО с открытым исходным кодом

### Факторы, которые следует учитывать вместе с вопросами на собеседовании с .NET программистом
Помимо конкретных технических вопросов, при оценке кандидатов на вакансию разработчиков .NET необходимо рассмотреть еще несколько областей:

- Портфолио проектов .NET - попросите кандидатов показать вам примеры своей прошлой работы, будь то динамическая веб-страница или какое-либо другое веб-приложение. Если у них нет примеров профессиональной работы, взгляните на некоторые личные проекты, которыми они занимались.
- Методологии разработки программного обеспечения - полезно знать, как кандидаты взаимодействовали с членами команды в других проектах. Большинство профессиональных разработчиков имеют обширный опыт работы со средами Agile , поэтому вы можете обсудить, считает ли они такой подход поддерживающим или отвлекающими их Scrums. Некоторые разработчики могут иметь опыт работы с новыми методами работы, такими как DevOps.
- Soft навыки - технические способности - не единственная особенность выдающегося сотрудника, поэтому не забывайте исследовать софт скиллс и мотивацию кандидатов . Коммуникация и сотрудничество важны для разработчиков, которым необходимо работать с людьми в нетехнических отделах, в то время как организация и управление временем важны для тех, кто работает в одиночку. Кроме того, если разработчики будут иметь доступ к конфиденциальным данным, обязательно оцените их с точки зрения этики и надежности.
		
				
# ЕЩЁ ПОВТОРЫ
				
### 1. Какие существуют типы классов в C#?
Пример: «Различные типы классов в C#:

Частичный класс — позволяет разделить его элементы или использовать их совместно с несколькими файлами .cs. Он обозначается ключевым словом «Частично».

Запечатанный класс — это класс, который не может быть унаследован. Чтобы получить доступ к членам закрытого класса, нам нужно создать объект класса. Он обозначается ключевым словом «Запечатанный».

Абстрактный класс — это класс, объект которого не может быть создан. Класс может быть только унаследован. Он должен содержать хотя бы один метод. Он обозначается ключевым словом «абстрактный».

Статический класс — это класс, который не допускает наследования. Члены класса также являются статическими. Он обозначается ключевым словом «статический». Это ключевое слово указывает компилятору проверять любые случайные экземпляры статического класса».

### 2. Что такое управляемый и неуправляемый код?
Пример: «Управляемый код — это код, который выполняется CLR (Common Language Runtime). Он называется «управляемым кодом» из-за того, что платформа .Net использует внутренний сборщик мусора для очистки неиспользуемой памяти. «__Неуправляемый код» — это любой код, который выполняется средой выполнения приложения любой другой платформы, кроме .Net. Среда выполнения приложения позаботится о безопасности, памяти и других операциях с производительностью».

### 3. Что такое класс и объект?
Пример: «Класс — это инкапсуляция методов и свойств, которые используются для представления объекта в реальном времени. Класс объединяет все экземпляры в единое целое. «Объект» — это экземпляр класса или блок выделенной памяти, который может храниться в виде переменных, массива или коллекции».

### 4. Объясните компиляцию кода на C#
Пример: * «Компиляция кода состоит из четырех шагов, которые включают в себя:

Компиляция исходного кода в управляемый код компилятором C#

Выполнение сборки с помощью CLR

Объединение нового кода в сборки

Загрузка общеязыковой среды выполнения (CLR)».

### 5. В чем разница между виртуальным методом и абстрактным методом?
Пример: «Виртуальный метод всегда должен иметь реализацию по умолчанию. Абстрактный метод не имеет реализации. Здесь нет необходимости в ключевом слове override, хотя его можно использовать».

### 6. Объясните пространства имен в C#
Пример: «Пространства имен используются для организации больших проектов кода. System — наиболее широко используемое пространство имен в C#».

### 7. Объясните полиморфизм
Пример: «В программировании полиморфизм означает один и тот же метод, но разные реализации. Он содержит два типа: время компиляции и время выполнения. Полиморфизм времени компиляции достигается за счет перегрузки операторов. Полиморфизм времени выполнения достигается переопределением. Примером может быть: класс имеет метод Void Add(), полиморфизм достигается за счет перегрузки метода, то есть void Add(int a, int b), void Add(int add) — все это перегруженные методы».

### 8. Как реализована обработка исключений в C#?
Пример: «Обработка исключений выполняется с помощью четырех ключевых слов в C#:

Try — содержит блок кода, проверяющий исключение.

Catch — это программа, которая перехватывает исключение с помощью обработчика исключений.

Наконец — это блок кода, написанный для выполнения, даже если исключение не перехвачено.

Throw — создает исключение при возникновении проблемы».

### 9. Что такое упаковка и распаковка?
Пример: «Преобразование типа значения в ссылочный тип называется «упаковкой». Явное преобразование того же ссылочного типа, который создается путем упаковки обратно в тип значения, называется «распаковкой».

### 10. Для чего используется массив?
Пример: «Массив используется для хранения нескольких переменных одного типа и представляет собой набор переменных, хранящихся в непрерывной области памяти».

### 11. Что такое управляющая последовательность? Назовите последовательности в C#
Пример: «Escape-последовательность обозначается обратной косой чертой (\). Обратная косая черта указывает, что символ, следующий за ним, следует интерпретировать буквально или что это специальный символ. Escape-последовательность считается одним символом».

### 12. Каковы основные операции над строками?
Пример: «Основные операции со строками: объединение, изменение, поиск, сравнение».

### 13. Что такое сериализация?
Пример: «Сериализация преобразует код в его двоичный формат с помощью процесса. После преобразования в байты его можно легко сохранить и записать на диск. Сериализация полезна для того, чтобы исходная форма кода не была потеряна и ее можно было восстановить позже».

### 14. Какие существуют типы делегатов?
Пример: «Различные типы делегатов: одиночный делегат, многоадресный делегат и общий делегат».

# https://github.com/miptleha/dotnet_dev

# Успехов в изучении C# и .NET. Пускай программирование приносит Вам радость!

### Вопрос 9. Является ли тип List потокобезопасной (thread-safe) коллекцией?
Тип List может быть потокобезопасным в операциях чтения.
Пользовательский код должен обеспечивать всю синхронизацию при параллельном добавлении элементов в несколько потоков или удалении элементов из них.

### Вопрос 10. В чем различие между операцией cast (приведения типов) и оператором as?
В случае ошибки cast выбрасывает исключение InvalidCastException, а оператор as возвращает null

### Вопрос 11. Какова алгоритмическая сложность для операций чтения и записи для коллекции Dictionary?
Чтение очень быстрое, потому что используются хэш-таблицы и сложность в этом случае стремится к O(1).
Запись проходит тоже очень быстро (O(1)), в том случае если .Count меньше емкости, если же больше, то скорость стремится к O(n).

### Вопрос 12. В чем различие между ключевыми словами "ref" и "out"?
Параметр с ключевым слово out может быть не инициализирован, а параметр с ключевым словом ref обязательно должен быть инииализирован до вызова метода, который использует эти параметры.

### Вопрос 15. В чем отличие необязательных параметров от именованных?
Необязательные параметры позволяют опускать аргументы функции, в то время как именованные параметры разрешают передавать аргументы по названию параметра.

public void optionalParamFunc(int p1, int p2 = 2, int p3 = 3); 
optionalParamFunc(1, p3:10); //это эквивалентно optionalParamFunc(1,2,10);

### Вопрос 16. Чем отличаются друг от друга классы String и StringBuilder?
Объект класса String представляет собой неизменяемую строку.
Когда выполняется какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места.
Объект класса StringBuilder представляет собой динамическую строку.
При создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке, а при добавлении к ней каких-либо элементов строка не пересоздается заново.
В том случае если выделенной памяти не будет хватать для добавления новых элементов, то емкость объекта будет увеличена.

### Вопрос 17. Какие отличие между значимыми и ссылочными типами?
Значимые типы (value type) хранятся в стеке. Стек - это структура данных, которая растет снизу вверх: каждый новый элемент помещаются поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве. А ссылочные типы (reference type) хранятся в куче, это другая область памяти, которую можно представить как неупорядоченный набор различных объектов. Когда создаётся объект ссылочного типа в стеке помещается ссылка на адрес в куче. Когда этот объект перестает использоваться, то ссылка уничтожается. После этого в дело вступает автоматический сборщик мусора: он видит, что на объект в куче нету больше ссылок, и удаляет этот объект и очищает память.

### Вопрос 18. Как и зачем использовать конструкцию using в C#?
Ключевое слово using упрощает работу с объектами которые реализуют интерфейс IDisposable.
Интерфейс IDisposable содержит один метод .Dispose(), который используется для освобождения ресурсов, которые захватил объект. При использовании using не обязательно явно вызывать .Dispose() для объекта.

### Вопрос 19. В чем отличие использования Finalize и Dispose?
Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя так просто переопределить. И фактическая его реализация происходит через создание деструктора. Вызывается сборщиком мусора, а точный момент вызова неопределен.
Метод Dispose нужен для ручного освобождения ресурсов, через его явный вызов или с помощью using.

### Вопрос 20. В чем основные отличия класса от структуры в языке C#?
Основные отличия класса от структуры следующие:

Структура является размерным типом, а класс – ссылочным.
Все структурные типы неявно наследуются от System.ValueType, они не бывают абстрактными и всегда неявно запечатаны (sealed)
При присваивании переменных структурного типа, создается копия данных
Объявления полей структуры не могут иметь инициализаторов
Различная интерпретация this для структуры и класса
Структура не может содержать конструктор без параметров
Структура не может содержать деструктор
Для ссылочных типов значение по умолчанию – null
При конвертировании между ссылочным и размерным типами происходит упаковка и распаковка.

### Вопрос 21. Как можно сравнить строки в C#?
```
string s1 = "123";
string s2 = s1.Substring(0, 2) + "3";

//по значению, все варианты сработают
if (s1 == s2) { }
if (s1.CompareTo(s2) == 0) { }
if (s1.Equals(s2)) { }
if (string.Equals(s1, s2)) { }

//по ссылке, не сработают, так сравнивать не надо
if ((object)s1 == (object)s2) { }
if (object.ReferenceEquals(s1, s2)) { }
```
				
### Вопрос 22. Что такое управляемый код и CLR? Основные требования к управляемому коду.
Управляемый код - код программы исполняемый под управлением CLR (Виртуальной машиной .Net).
CLR (общеязыковая исполняющая среда) — исполняющая среда для байт-кода CIL (MSIL), в которой компилируются программы, написанные на .NET-совместимых языках программирования (C#, Managed C++, Visual Basic .NET, F# и прочие). CLR является одним из основных компонентов пакета Microsoft .NET Framework.
Написанный управляемый код должен быть полностью совместим с CTS(Common Type System), который поддерживают все .Net совместимые языки.

### Вопрос 23. Разница IEnumerable и IQueryable при работе с удаленной БД?
IEnumerable. Объект IEnumerable представляет набор данных в памяти и может перемещаться по этим данным только вперед.
IQueryable. Он располагается в пространстве имен System.Linq. Объект предоставляет удаленный доступ к базе данных и позволяет перемещаться по данным как в прямом порядке от начала до конца, так и в обратном порядке. В процессе же выполнения запроса, происходит оптимизация запроса.

IEnumerable<Phone> phoneIEnum = db.Phones;
var phones1 = phoneIEnum.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES, фильтрация на стороне клиента
IQueryable<Phone> phoneIQuer = db.Phones;
int id = 3;
var phones2 = phoneIQuer.Where(p => p.Id > id).ToList(); //SELECT * FROM PHONES WHERE ID > 3

### Вопрос 24. Что такое абстракция и как она связана с ООП?
Под абстракцией понимается модель реальной жизни упрощенная для решения конкретной задачи, которая выражена в объекте, т.е. любой объект - это абстракция, т.к. она только частично описывает реальную сущность. Поэтому любой объект можно считать абстракцией и он только частично описывает реальную сущность. Во время преобразования реальных сущностей в объект, он лишается тех характеристик, которые являются несущественными деталями.
Например можно составить упрощенный класс человека, который умеет двигаться, а от всего остального мы абстрагируемся (в данным случае несущественно то, что он умеет дышать, кушать, видеть, слышать и т. д.)

### Вопрос 25. Что такое IoC (Inversion of Control/инверсия управления) и для чего она нужна?
Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.

### Вопрос 26. Что такое DI (Dependency Injection) контейнер?
DI контейнер это один из способов реализации принципа IoC. Этот контейнер знает о всех интерфейсах и их реализациях в системе и умеет их сопоставлять. Перед началом работы с ним необходимо зарегистрировать известные типы и их сопоставления(интерфейс-->реализация).

### Вопрос 27. Какие реализации DI контейнеров вы знаете на C#. Какой DI контейнер является лучшим?
Castle Windsor, Autofac, Ninject, Unity...и так далее, на самом деле их очень много. На счет того, какой из них лучший не совсем корректный вопрос. Все зависит от конкретной реализации.

### Вопрос 28. Что подразумевается под свойствами в C#?
В C# существуют специальные методы доступа, которые и именуются свойствами. Они обеспечивают простой доступ к полям класса для получения или установки их значения. Определение свойства содержит блоки get и set. В блоке get возвращается значение поля, а в блоке set устанавливается с помощью параметра value, которое представляет передаваемое значение.

### Вопрос 29. Что такое assembly manifest (манифест сборки)?
Манифест сборки содержит следующую информацию (первые чертыре составляют удостоверение сборки):

Имя сборки
Номер версии: основной и дополнительный номера. Используется для управления версиями
Язык и региональные параметры: информация о языке и региональных параметрах, которые поддерживает сборка
Информация о строгом имени: открытый ключ издателя
Список всех файлов сборки: хэш и имя каждого из входящих в сборку файлов
Список ссылок на другие сборки, которые использует текущая сборка
Список ссылок на типы, используемые сборкой

### Вопрос 30. Что такое GAC? Возможно ли поместить два файла с одинаковым именем в Global Assembly Cache?
GAC (Global Assembly Cache) - глобальный кэш сборок, место где хранятся разделяемые сборки. В GAC нельзя помещать полностью одинаковые сборки (сборки с полностью совпадающим сложным именем). Сложное имя сборки состоит из нескольких частей:

Имя сборки без расширения
Номер версии. Благодаря разграничению по версии можно хранить разные версии одной и ой же сборки
Открытый ключ
Необязательное значение для культуры (при локализации сборки)
Цифровая подпись, которая создается с помощью хэш-значения содержимого сборки и значения секретного ключа. Секретный ключ представляет собой файл с расширением *.snk. Если совпадают у двух сборок только имена сборки, а все остальное отличается, то их можно помещать в GAC вместе.

### Вопрос 31. Какие модификаторы доступа существуют в C#?
В C# применяются следующие модификаторы доступа:

public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.
protected: такой член класса доступен из любого места в текущем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).
protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.
private protected: такой член класса доступен из любого места в текущем классе или в производных классах, которые определены в той же сборке.
Вопрос 32. Что такое Boxing и Unboxing?
Упаковка представляет собой процесс неявный преобразования типа значения (хранящегося в стеке) в тип object. Когда тип значения упаковывается средой CLR, она создает оболочку значения внутри System.Object и сохраняет ее в управляемой куче. Обратная операция распаковки осуществляется явным преобразованием object в тип значения. Если упакованный объект не соответствует требуемому типу, то выбрасывается исключение InvalidCastException.

### Вопрос 33. В чем суть полиморфизма?
Полиморфизм – способность функции обрабатывать данные разных типов.

Ad-hoc полифорфизм (перегрузка функций, приведение типа) — можно создать несколько методов с одним именем и разными аргументами, примитивные типы могут неявно приводиться.
Параметрический полиморфизм (обобщённое программирование) — можно создать полиморфные (обобщённые) типы.
Полиморфизм включения (наследование) — интерфейсы, наследование классов, виртуальные функции.

### Вопрос 34. Какие типы можно использовать в предложении foreach?
Можно использовать типы, которые реализуют интерфейс IEnumerable или IEnumerable<T>.
Либо же к любым типам которые удовлетворяют следующим условиям:

Включают открытый метод GetEnumerator без параметров с классом, структурой или тип интерфейсом в качестве возвращаемого значения;
Тип возвращаемого значения метода GetEnumerator должен содержать открытое свойство Current и открытый метод MoveNext без параметров с типом возвращаемого значения Boolean.

### Вопрос 35. Чем отличается event от delegate?
Отличаются так же, как отличаются свойства от полей.
Событие может быть только членом класса и может быть запущено только в классе, в котором объявлено. Кроме того, подписчик события не может отписать других подписчиков.
Событие реализуется компилятором в виде приватного поля-делегата и двух публичных методов подписки/отписки на событие.

### Вопрос 36. Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы? Если да, то каким образом?
Может. Общие методы при этом надо реализовывать один раз неявно или два раза явно (с указанием имени интерфейса). При явной реализации метод нельзя будет вызывать без приведения экземпляра класса к интерфейсу (если только не будет третьей реализации метода в классе).
Если два метода интерфейса выполняют разные действия, то неявная реализация интерфейсов может быть некорректной.

### Вопрос 37. Объясните разницу между System.Array.CopyTo() и System.Array.Clone()?
CopyTo требует наличия выходного массива, тогда как Clone создает новый массив.
CopyTo позволяет указывать индекс элемента, начиная с которого производить копирование.

### Вопрос 38. Что такое абстрактный класс? В каком случае вы обязаны объявить класс абстрактным?
Абстрактный класс - это класс, имеющий неполную реализацию, которую реализует его неабстрактный наследник. Нельзя создать экземпляр абстрактного класса.
Абстрактные классы нужны для того, чтобы выделять общий функционал от нескольких классов в обособленный класс. От этого отдельного класса потом можно унаследовать либо просто сигнатуру функционала, либо вместе с реализацией.
Класс обязательно нужно объявлять как абстрактный когда он содержит абстрактные члены.

### Вопрос 39. Назовите отличия между интерфейсом и абстрактным классом?
Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.
Абстрактные классы и интерфейсы используются в наследовании, при этом разрешено наследование нескольких интерфейсов, но только одного класса.

### Вопрос 40. В чем разница между абстрактными и виртуальными классами? Между виртуальными и абстрактными методами?
Абстрактные классы это класс помеченный ключевым словом abstract. В абстрактном классе содержатся абстрактные члены (методы, свойства, индексаторы, события) они не имеют внутренней реализации и выступают в роли интерфейса. Они так же обязаны быть помечены ключевыми словом abstract. При наследовании от абстрактного класса, класс наследник получает все свойства своего класса родителя, а если в родительском классе есть еще и абстрактные члены, то в классе наследнике обязательно их нужно переопределять.
Виртуальный класс, это просто класс в котором есть виртуальные члены (методы, свойства...) Виртуальные члены помечаются модификатором virtual и имеют внутреннюю реализацию, которая может быть переопределена в классе наследнике.

### Вопрос 41. Что означает модификатор virtual?
Модификатор virtual служит для того, чтобы помечать виртуальные методы или свойства в классе родителя. Виртуальные методы (свойства) - это такие методы, которые мы хотим переопределить в классах наследниках. А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override. Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.
Переопределять можно и невиртуальные методы, но тогда выбор метода (родителя или наследника) будет осуществляться статически во время компиляции на основании типа переменной, а не типа объекта, хранящейся в ней.

### Вопрос 42. В чем разница инкапсуляции и сокрытия?
Инкапсуляция - одна из парадигм ООП. Она представляет собой способность языка упаковывать определённые участки кода в контейнеры, исключая возможность внешнего мира нарушения целостности данного кода. Основной единицей инкапсуляции в C# является класс. Инкапсуляция позволяет структурировать код и помогает обезопасить его от многих возможных проблем, относительно защиты данных и информации.
Сокрытие же скрывает детали о процессе. Для определения прав доступа к данным в классе и к классу непосредственно используются модификаторы доступа. Получается, что использование этих модификаторов и есть то самое сокрытие. Но сам термин "сокрытие" лучше употреблять в контексте методов. Сокрытие метода представляет собой реализация тела метода в дочернем классе, сигнатура которого соответствует сигнатуре метода в родительском классе. Для сокрытия применяется ключевое слово "new".

### Вопрос 43. Что такое частные и общие сборки?
Частные сборки:
```
Видны только самому приложению
Нет необходимости заботиться об уникальном имени во всем глобальном пространстве имен
Не нужно делать записей в реестре при развертывании приложения
Сборки просто копируются в директорию приложения или в подчинённую директорию
Общая среда выполнения (CLR) при запуске приложения прочитает его манифест и определит какие сборки необходимы. Затем будет произведен поиск нужной сборки по директории приложения (процесс зондирования) Общие сборки:
Общие сборки могут быть использованы сразу несколькими приложениями
Сборка должна иметь строгое имя (strong name)
Сборка должна быть помещена в общедоступное место – Global Assembly Cache (GAC, глобальный кэш сборок)
Вопрос 44. Что такое .Net Framework?
.NET Framework — программная платформа, выпущенная компанией Microsoft в 2002 году. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), которая подходит для разных языков программирования. Функциональные возможности CLR доступны в любых языках программирования, использующих эту среду.
```
	
### Вопрос 45. Чем управляемый код (managed code) отличается от неуправляемого (unmanaged code)?
Управля́емый код (managed code) — термин, введённый фирмой Microsoft, для обозначения кода программы, исполняемой под «управлением» виртуальной машины .NET — Common Language Runtime или Mono. При этом машинный код называется неуправля́емым кодом (unmanaged code).
Слово «управляемый» относится к методу обмена информацией между программой и исполняющей средой. Оно означает, что в любой точке исполнения управляющая среда может приостановить исполнение и получить информацию, специфичную для текущего состояния. Необходимая для этого информация представлена в управляемом коде на языке Intermediate Language и в связанных с этим кодом метаданных.

### Вопрос 46. LINQ lazy loading, eager loading в чем разница?
В случае lazy loading (ленивая загрузка), зависимые таблицы (дочерние объекты) не загружаются автоматически с родительскими, а загрузятся в тот момент, когда они понадобятся. В LINQ по умолчанию используется lazy loading. В случае eager loading (жадной загрузки), зависимые объекты загружаются автоматически с родительской таблицей. Для того, чтобы использовать eager loading нужно применить метод Include().

### Вопрос 47. Можно ли запретить наследование от своего собственного класса?
Для того, чтобы запретить наследоваться от класса необходимо объявить его с модификатором sealed.

### Вопрос 48. Можно ли разрешить наследование класса, но запретить переопределение метода?
Можно для второго класса в иерархии наследования, если переопределяем виртуальный метод как sealed override, тогда дальнейшее переопределение по цепочке наследования запрещено.

### Вопрос 49. Определение паттерна синглтон
Одиночка (Singleton, Синглтон) - порождающий паттерн, который гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому объекту точку доступа. Используется тогда, когда необходимо, чтобы для класса существовал только один экземпляр. Синглтоны бывают потокобезопасные и нет, с простой и отложенной инициализацией.
```
class Singleton
{
    private static readonly Singleton _instance = new Singleton();
    private Singleton() {}
    static Singleton() {}
    public static Singleton Instance { get { return _instance; } }
}
```

### Вопрос 50. Thread, task, примеры использования?
Класс Thread создает и контролирует поток. На входе указывается метод, который будет выполняться в потоке.
Класс Task позволяет запускать отдельную продолжительную задачу. Она запускается асинхронно в одном из потоков из пула потоков, но ее можно запускать и синхронно.
```
var t = new Thread(() => Thread.Sleep(1000));
t.IsBackground = false; //основной поток, система сама ожидает его завершение
t.Start();
Task.Run(() => Task.Delay(1000)).Wait(); //с использованием TPL
```

### Вопрос 51. Что такое интеграционные тесты и unit-тесты?
Модульное тестирование: проверка отдельного модуля (класса, библиотеки) приложения независимо от другого модуля. Позволяет провести регресионное тестирование (при внесении изменений в модуль, убедиться, что он по прежнему работает).
Интеграционное тестирование: программные модули объединяются и тестируются в группе. Эти тесты проверяют правильность взаимодействия нескольких подсистем (например, двух классов). Проводится после модульного тестирования.
Системное тестирование: проверяется все приложение в целом на соответсвие требованиям по принципу черного ящика (без учета внутреннего строения приложения).

### Вопрос 52. Что такое MVVM?
Шаблон MVVM (Model-View-ViewModel) позволяет отделить логику приложения от визуальной части, используется в WPF. Основные компоненты:

Модель (Model) описывает используемые в приложении данные. Модели могут содержать логику, непосредственно связанную этими данными, например, логику валидации свойств модели.
Представление (View) — определяет визуальный интерфейс (кнопки, текстовые поля и прочие визуальные элементы), через который пользователь взаимодействует с приложением.
Модель Представления (ViewModel) — связывает модель и представление через механизм привязки данных. Если в модели изменяются значения свойств, автоматически идет изменение отображаемых данных в представлении, хотя напрямую модель и представление не связаны. ViewModel также содержит логику по получению данных из модели, которые потом передаются в представление. И также VewModel определяет логику по обновлению данных в модели.

### Вопрос 54. Когда использовать StringBuilder предпочтительнее, чем string?
StringBuilder предпочтительнее использовать если строка часто изменяется.

### Вопрос 59. Какой уровень доступа имеют поля класса, если модификатор доступа не указан?
Если не указывать модификатор доступа для поля класса, то по умолчанию они объявляются с модификатором private. Для всех модификаторов доступа действует правило: если не указан модификатор, то устанавливается максимально строгий, при котором код будет компилироваться.

### Вопрос 60. Каким образом можно присвоить значения полям, которые помечены ключевым словом readonly?
Из конструктора, либо в месте объявления поля, приравнивая ему какое-то значение.

### Вопрос 61. Какая из операций linq исключает дублирование одинаковых элементов в выходной последовательности?
Операция Distinct удаляет дублированные элементы из входной последовательности.

### Вопрос 62. С помощью какого ключевого слова осуществляется блокировка одновременного выполнения определенных участков кода несколькими потоками?
Для осуществления блокировки одновременного выполнения определенных участков кода несколькими потоками используется ключевое слово lock. lock определяет блок, внутри которого весь код становится недоступным для других потоков до завершения работы текущего потока.

### Вопрос 63. Какой интерфейс должен реализовать класс, чтобы к переменной данного типа был применим оператор foreach?
Оператор foreach может применяться для переменных, которые реализуют интерфейс IEnumerable или IEnumerable, либо к экземпляру любого типа, удовлетворяющим условиям:

должен включать открытый метод GetEnumerator без параметров с классом, структурой или типом интерфейса в качестве возвращаемого значения;
тип возвращаемого значения метода GetEnumerator должен содержать открытое свойство Current и открытый метод MoveNext без параметров с типом возвращаемого значения Boolean.
	
### Вопрос 64. Когда вызывается статический конструктор класса?
Статический конструктор вызывается автоматически для инициализации класса перед созданием первого экземпляра типа или при первом обращении к каким-либо статическим членам.

### Вопрос 65. Чем отличаются константы и поля, доступные только для чтения?
Константы инициализируются только во время компиляции, а поля, доступные для чтения, могут инициализироваться и в месте определения и во время выполнения в конструкторе.

	
# https://viduus.net/spisok-voprosov-c-sobesedovanie/
	
### Что такое MVC, MVVM, WEB API?			
				
https://techrocks.ru/2021/01/12/net-job-interview-questions/		
				
